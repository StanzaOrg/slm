defpackage slm/dependency:
  import core

  import semver
  import term-colors
  import maybe-utils

  import slm/logging
  import slm/utils
  import slm/flags

public deftype Dependency
public defmulti name (d: Dependency) -> String
public defmulti path (d: Dependency) -> String
public defmulti version-string? (d: Dependency) -> Maybe<String>:
  None()

; Dependencies specified by path (e.g. `foo = { path = "../foo" }`)
public defstruct PathDependency <: Dependency:
  name: String with: (as-method => true)
  path: String with: (as-method => true)

; Dependencies specified by Git locator/version (e.g. `foo = "myorg/myuser|1.0.0"`)
public defstruct GitDependency <: Dependency:
  name: String with: (as-method => true)
  locator: String
  version: SemanticVersion
  hash: String with: (updater => sub-hash)

defmethod path (d: GitDependency):
  path-join(SLM_DEPS_DIR, name(d))

defmethod version-string? (d: GitDependency) -> One<String>:
  One(version-string(d))

public defn version-string (d: GitDependency) -> String:
  to-string(version(d))

public defn colored-version? (d: GitDependency) -> ColoredString:
  ColoredString(version-string(d))
    $> bold $> foreground{_, TerminalBrightGreen}
    $> clear-color?

public defn colored-name? (d: Dependency) -> ColoredString:
  ColoredString(name(d))
    $> bold $> foreground{_, TerminalBrightWhite}
    $> clear-color?

public defn parse-git-dependency (name: String, specifier: String):
  GitDependency(name, locator, requested-version, hash)
where:
  val [locator, requested-version] = parse-specifier(specifier)
  val hash = ""

defn parse-specifier (specifier: String) -> [String, SemanticVersion]:
  val elements = to-tuple $ split(specifier, "|")
  switch(length(elements)):
    2:
      val url = elements[0]
      val version = elements[1]
        $> parse-semver
        $> expect{_, "couldn't parse '%_'" % [specifier]}
      [url, version]
    else:
      error("malformed specifier '%_'" % [specifier])


; This function was shamelessly stolen from lbstanza:compiler/config.stanza
; https://github.com/StanzaOrg/lbstanza/blob/0cbcd2ce7d8b1794e82624170a0a09d3053d0fb1/compiler/config.stanza#L298
; Sadly - it is not public so I can't just invoke it directly.
defn sub-curly (f:String -> String, s:String) -> String :
  if index-of-char(s, '{') is False :
    s
  else :
    val buffer = StringBuffer()

    ;Iterate through the curlies
    let loop (start:Int = 0) :
      ;Determine curly bounds
      val [i, j] = let :
        val i = index-of-char(s, start to false, '{')
        match(i:Int) :
          [i, index-of-char(s, (i + 1) to false, '}')]
        else : [i, false]
      ;If there is a curly
      match(i:Int, j:Int) :
        ;Add string up to curly
        if start < i :
          add-all(buffer, s[start to i])
        ;Add replacement
        val replacement = f(s[(i + 1) through (j - 1)])
        add-all(buffer, replacement)
        ;Continue past } char
        loop(j + 1)
      else :
        ;End of string, add the rest
        if start < length(s) :
          add-all(buffer, s[start to false])

    ;Return spliced string
    to-string(buffer)

defn env-var-substitute (path:String) -> String:
  within name = sub-curly(path):
    get-env!(name)

public defn parse-path-dependency (name: String, path: String) -> PathDependency:
  val path* = env-var-substitute(path)
  PathDependency(name, path*)
