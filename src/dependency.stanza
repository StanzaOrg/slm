defpackage slm/dependency:
  import core

  import semver
  import term-colors
  import maybe-utils

  import slm/logging
  import slm/utils
  import slm/file-utils
  import slm/string-utils
  import slm/flags

public deftype Dependency
public defmulti name (d: Dependency) -> String
public defmulti path (d: Dependency) -> String
public defmulti version-string? (d: Dependency) -> Maybe<String>:
  None()
doc: \<DOC>
Indicates whether a dependency should be parsed recursively.

Typical dependencies like git/path depedencies have a `slm.toml`
file that we will need to parse and then recursively discover
dependencies with.

Other deps, like the `TaskDependency` does not have an `slm.toml`
and is primarily for executing a command/process for external
initialization.

This flag is for differentiating between these two types of
dependency.
<DOC>
public defmulti recursive (d:Dependency) -> True|False :
  true

doc: \<DOC>
Tool for filtering dependencies for recursives only.
<DOC>
public defn recursive-deps-only (deps:Seqable<Dependency>) -> Seqable<Dependency> :
  for dep in deps filter:
    recursive(dep)

public defstruct UnknownDependencyTypeError <: Exception :
  dep:Dependency

public defmethod print (o:OutputStream, e:UnknownDependencyTypeError):
  val msg = "Unknown and Unhandled Dependency Type: %_" % [dep(e)]
  print(o, msg)

; Dependencies specified by path (e.g. `foo = { path = "../foo" }`)
public defstruct PathDependency <: Dependency:
  name: String with: (as-method => true)
  path: String with: (as-method => true)
  version?: Maybe<SemanticVersion> with: ( default => None() )

defmethod version-string? (d:PathDependency) -> Maybe<String>:
  match(version?(d)):
    (x:None): x
    (x:One<SemanticVersion>): One $ to-string(x)

public defn version-string! (d:PathDependency) -> String:
  to-string $ value-or(version?(d), "UNSPECIFIED")

defmethod print (o:OutputStream, d:PathDependency) :
  print(o, "%_ = { path = \"%_\"" % [name(d), path(d)])
  match(version?(d)):
    (x:None): print(o, " }")
    (x:One<SemanticVersion>): print(o, ", version = \"%_\" }" % [to-string $ value(x)])

; Dependencies specified by Git locator/version (e.g. `foo = "myorg/myuser|1.0.0"`)
public defstruct GitDependency <: Dependency:
  name: String with: (as-method => true)
  locator: String
  version: SemanticVersion
  hash: String with: (updater => sub-hash)

defmethod path (d: GitDependency):
  path-join(SLM_DEPS_DIR, name(d))

defmethod version-string? (d: GitDependency) -> One<String>:
  One(version-string(d))

defmethod print (o:OutputStream, d:GitDependency) :
  print(o, "%_ = { git = \"%_\", version = \"%_\" }" % [name(d), locator(d), version-string(d)])

public defn version-string (d: GitDependency) -> String:
  to-string(version(d))

public defn colored-version? (d: GitDependency) -> ColoredString:
  ColoredString(version-string(d))
    $> bold $> foreground{_, TerminalBrightGreen}
    $> clear-color?

public defn colored-name? (d: Dependency) -> ColoredString:
  ColoredString(name(d))
    $> bold $> foreground{_, TerminalBrightWhite}
    $> clear-color?


doc: \<DOC>
Legacy Version of the Git Dependency Parser

The legacy version uses a string in the form `name|0.1.2`
where `0.1.2` is the version for the dependency.
<DOC>
public defn parse-git-dependency (name: String, specifier: String):
  info("Extracting Legacy Github Dependency Specifier for '%_'. Consider Upgrading to Toml Table Variable" % [name])
  GitDependency(name, locator, requested-version, hash)
where:
  val [locator, requested-version] = parse-specifier(specifier)
  val hash = ""

defn parse-specifier (specifier: String) -> [String, SemanticVersion]:
  val elements = to-tuple $ split(specifier, "|")
  switch(length(elements)):
    2:
      val url = elements[0]
      val version = elements[1]
        $> parse-semver
        $> expect{_, "couldn't parse '%_'" % [specifier]}
      [url, version]
    else:
      error("malformed specifier '%_'" % [specifier])

public defn parse-git-dependency (name:String, locator:String, version?:Maybe<String>) -> GitDependency :
  val version = match(version?):
    (x:None):
      throw $ Exception("Invalid Git Dependency[%_]: No Version Attribute found"% [name])
    (x:One<String>):
      parse-semver(value(x)) $>
        expect{_, "Git Dep[%_]: Failed to Parse Version: '%_'" % [name, x]}

  val hash = "" ; This gets resolved during the fetch/sync
  GitDependency(name, locator, version, hash)

public defn parse-path-dependency (name: String, path: String, version?:Maybe<String>, env-sub-enable:True|False) -> PathDependency:
  val path* = un-norm-path $ if env-sub-enable:
    env-var-substitute(path)
  else:
    path

  val version = match(version?):
    (x:None): x
    (x:One<String>):
      val sver = parse-semver(value(x)) $> expect{_, "SemanticVersion: couldn't parse  '%_'" % [x]}
      One(sver)
  PathDependency(name, path*, version)
