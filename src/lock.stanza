defpackage slm/lock:
  import core

  import maybe-utils
  import semver
  import toml

  import slm/dep-types
  import slm/errors
  import slm/file-utils
  import slm/flags
  import slm/logging
  import slm/task
  import slm/utils

; What is a lock file?
; A lock file replaces your slm.toml -- if it is present, your slm.toml is
; functionally ignored when you run `slm build`
;
; That means it must encode each dependency's exact hash as well as its
; version and name.
;
; The format of a slm.lock file is as follows:
; <dependency-name> = { version = "<tag>", (locator = "<uri>")? hash = "<hash>" }

public deftype LockedDependency <: Equalable
public defmulti name (d: LockedDependency) -> String

public defstruct LockedPathDependency <: LockedDependency:
  name: String with: (as-method => true)
with:
  equalable => true

public defstruct LockedGitDependency <: LockedDependency:
  name: String with: (as-method => true)
  locator: String
  version: SemanticVersion
  hash: String
with:
  equalable => true

public defstruct LockedPkgDependency <: LockedDependency:
  name: String with: (as-method => true)
  version: String
  type: String
  options: Tuple<KeyValue<String, String>>
with:
  equalable => true

public defstruct LockedTaskDependency <: LockedDependency:
  name: String with: (as-method => true)
  hash: String
with:
  equalable => true

public defn parse-slm-lock-file (f:InputStream) -> Tuple<LockedDependency>:
  val content = slurp-stream(f)
  val table = parse-string(content) $> table $> to-seq $> pairs
  to-tuple $ for [name, dependency] in table seq:
    match(dependency: TomlTable):
      match(get?(dependency, "locator"), get?(dependency, "type"), get?(dependency, "version"), get?(dependency, "options"), get?(dependency, "hash")):
        (locator?: One, type?: None, version?: One, options?: None, hash?: One):
          val locator = value!(locator?) as String
          val version = value!(version?) $> parse-semver $> value!
          val hash    = value!(hash?) as String
          LockedGitDependency(name, locator, version, hash)
        (locator?: None, type?: One, version?: One, options?: One, hash?: None):
          val type    = value!(type?) as String
          val version = value!(version?) as String
          val options = value!(options?) as Tuple<KeyValue<String, String>>
          LockedPkgDependency(name, version, type, options)
        (locator?: None, type?: None, version?: None, options?: None, hash?: One):
          val hash = value!(hash?) as String
          LockedTaskDependency(name, hash)
        (locator?: None, type?: None, version?: None, options?: None, hash?: None):
          LockedPathDependency(name)
        (locator, type, version, options, hash):
          error("lock entry '%_' invalid: has it been corrupted?" % [name])
    else:
      error("lock format invalid: has it been corrupted?")

public defn write-slm-lock-file (f:OutputStream, dependencies: Tuple<Dependency>) -> False:
    for dep in dependencies do:
      match(dep):
        (dep: GitDependency):
          println(f, "%_={locator=%~,version=%~,hash=%~}"
                  % [name(dep), locator(dep), to-string(version(dep)), hash(dep)])
        (dep: PkgDependency):
          println(f, "%_={version=%~,type=%~,options=%~}"
                  % [name(dep), to-string(version(dep)), type(dep), to-string(options(dep))])
        (dep: PathDependency):
          println(f, "%_={}" % [name(dep)])
        (dep: TaskDependency):
          println(f, "%_={ hash=%~ }" % [name(dep), to-string(hash(dep)) ])
