defpackage slm/toml:
  import core
  import collections

  import semver
  import maybe-utils
  import toml/file
  import toml/parser
  import toml/table
  import toml/value

  import slm/dependency
  import slm/logging
  import slm/utils
  import slm/errors

public defstruct SlmToml:
  name: String
  version: String
  compiler?: Maybe<String>
  stanza-version?: Maybe<String>
  dependencies: HashTable<String, Dependency> with: (updater => sub-deps)

public defn SlmToml (
  name: String
  version: String
  deps: Tuple<KeyValue<String, Dependency>>
  --
  compiler? = ?
  stanza-version? = ?
  ):
  val deps* = to-hashtable<String, Dependency>(deps)
  SlmToml(name, version, compiler?, stanza-version?, deps*)

doc: \<DOC>
Extract the Semantic Version for the Stanza Version specification

@return If None - it means that no version spec is required.
If One - then this value is the semantic version required by this
configuration file.
<DOC>
public defn get-stanza-version? (cfg:SlmToml) -> Maybe<SemanticVersion> :
  match(stanza-version?(cfg)):
    (x:None): x
    (raw-str?:One<String>):
      val raw-str = value(raw-str?)
      val vers? = parse-semver(raw-str)
      One $ value-or-throw(vers?, InvalidVersionError(raw-str))

doc: \<DOC>
Parse the SLM TOML configuration file

@param path Path to the file to parse.
@param env-sub-enable Allow environment variable substitutions.
This will replace strings like `{HOME}` with environment variable
values if they exist.
<DOC>
public defn parse-slm-toml (path: String -- env-sub-enable:True|False = true) -> SlmToml:
  val table = path $> parse-file $> table
  val name = table["name"] as String
  val version = table["version"] as String
  val compiler? = extract-as-str? $ get?(table, "compiler")
  val stanza-version? = extract-as-str? $ get?(table, "stanza-version")
  val dependencies = to-hashtable<String, Dependency> $
    for [name, specifier] in pairs(table["dependencies"] as TomlTable) seq:
      name => match(specifier):
        (legacy:String):
          parse-git-dependency(name, legacy)
        (table:TomlTable):
          parse-dependency(name, table, env-sub-enable)

  SlmToml(name, version, compiler?, stanza-version?, dependencies)

defn extract-as-str? (v:Maybe<TomlValue>) -> Maybe<String> :
  match(v):
    (x:None): x
    (x:One<TomlValue>): One $ (value(x) as String)

defn parse-dependency (name:String, table:TomlTable, env-sub-enable:True|False) -> Dependency :
  val pathAttr = extract-as-str? $ get?(table, "path")
  val gitAttr = extract-as-str? $ get?(table, "git")
  val version = extract-as-str? $ get?(table, "version")
  match(pathAttr, gitAttr):
    (p:One<String>, g:One<String>):
      throw $ Exception("Invalid Dependency[%_]: The 'path' and 'git' attributes are mutually exclusive" % [name])
    (p:One<String>, g:None): ; Path Dependency
      parse-path-dependency(name, value(p), version, env-sub-enable)
    (p:None, g:One<String>): ; Git Dependency
      parse-git-dependency(name, value(g), version)
    (p:None, g:None):
      throw $ Exception("Invalid Dependency[%_]: Expected either a 'path' or 'git' attribute but found neither" % [name])


doc: \<DOC>
Output the SlmToml config as a valid TOML file.
<DOC>
public defmethod write (o:OutputStream, cfg:SlmToml) :
  println(o, "name = \"%_\"" % [name(cfg)])
  println(o, "version = \"%_\"" % [version(cfg)])
  match(compiler?(cfg)):
    (x:One<String>): println(o, "compiler = \"%_\"" % [x] )
    (_:None): false
  println(o, "[dependencies]")
  for dep in values(dependencies(cfg)) do:
    println(o, dep)

public defn find-dependency (cfg:SlmToml, name:String) -> Maybe<Dependency> :
  val deps = dependencies(cfg)
  for dep-name in keys(deps) first :
    One(deps[name]) when name == dep-name else None()
