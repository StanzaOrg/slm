defpackage slm/libgit-utils:
  import core
  import collections

  import libgit2

  import slm/logging

;============================================================
;====================== Libgit2 Utils =======================
;============================================================

public defstruct LibGitException <: Exception :
  code: git_error_code
  msg: ?

public defmethod print (o:OutputStream, e:LibGitException):
  print(o, "git error: %_" % [msg(e)])

; Finds and returns the object ID of the reference 'refish' in the repository at
; 'path'
; Throws an exception if unsuccessful
public defn libgit-rev-parse (path:String, refish:String) -> String :
  libgit2_init()

  ; Open
  val repo = match(libgit2_repository_open(path)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "failed to open git repository at %_: %_" % [path, last-err-msg]))

  ; Rev-parse
  val result = match(libgit2_revparse(repo, refish)):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to parse %_: %_" % [refish, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()

  result

; Performs the following steps in order:
; 1. Shallow clones the repository at 'url' to path 'path'
; 2. Fetches objects and references from the remote 'remote-name' with a refspec
;    which limits updates to the specified tag
; 3. Checks out the tag 'tag' (forcefully if 'force?' is true)
; Throws an exception if unsuccessful
public defn libgit-clone-tag (url:String,
                              path:String,
                              remote-name:String,
                              tag:String,
                              force?:True|False = false) -> False :

  val full-tag = to-string("refs/tags/%_" % [tag])
  val refspec = to-string("+%_:%_" % [full-tag, full-tag])

  libgit2_init()

  ; Clone
  val repo = match(libgit2_clone(url, path, 1)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "failed to clone %_: %_" % [url, last-err-msg]))

  ; Fetch
  match(libgit2_fetch(repo, remote-name, refspec, 1)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to fetch %_ from %_: %_" % [tag, url, last-err-msg]))

  ; Checkout
  val checkout-strat = GIT_CHECKOUT_FORCE when force? else GIT_CHECKOUT_SAFE
  match(libgit2_checkout(repo, full-tag, checkout-strat)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to checkout %_ from %_: %_" % [tag, url, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()
  false

; Performs the following steps in order:
; 1. Opens the repository at path 'path'
; 2. Finds the object ID of the repository HEAD
; 3. Fetches references from the remote 'remote-name', but only updates the
;    local reference 'tag' to match the remote
; 4. Finds the object ID of the tag 'tag'
; 5. If (1) and (3) differ, checks out the tag 'tag' in detached mode
;    (forcefully if 'force?' is true)
;    If 'sync-info-msg' is supplied, info() will be called with it
; Throws an exception if unsuccessful
public defn libgit-sync-tag (path:String,
                             remote-name:String,
                             tag:String,
                             force?:True|False = false,
                             sync-info-msg:Printable|String|False = false) -> False :
  libgit2_init()

  val full-tag = to-string("refs/tags/%_" % [tag])
  val refspec = to-string("+%_:%_" % [full-tag, full-tag])

  ; Open
  val repo = match(libgit2_repository_open(path)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "failed to open git repository at %_: %_" % [path, last-err-msg]))

  ; Rev-parse HEAD
  val head-hash = match(libgit2_revparse(repo, "HEAD")):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to find hash of HEAD: %_" % [last-err-msg]))
  debug("head-hash: %_" % [head-hash])

  ; Fetch
  match(libgit2_fetch(repo, remote-name, refspec, 1)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to fetch %_: %_" % [tag, last-err-msg]))

  ; Rev-parse tag
  val tag-hash = match(libgit2_revparse(repo, full-tag)):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "failed to parse %_: %_" % [tag, last-err-msg]))
  debug("tag-hash: %_" % [tag-hash])

  ; Checkout
  if head-hash != tag-hash :
    match(sync-info-msg:Printable|String) :
      info(sync-info-msg)
    val checkout-strat = GIT_CHECKOUT_FORCE when force? else GIT_CHECKOUT_SAFE
    match(libgit2_checkout(repo, full-tag, checkout-strat)):
      (e:GIT_OK) :
        false
      (e:git_error_code) :
        val last-err-msg = message(libgit2_error_last())
        libgit2_repository_free(repo)
        libgit2_shutdown()
        throw(LibGitException(e, "failed to checkout %_: %_" % [tag, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()
  false

; Returns a table of hash => reference name for all tags of the remote at the
; URL 'remote-url'
; Throws an exception if unsuccessful
public defn libgit-lsremote-tags (remote-url:String) -> HashTable<String,String> :
  libgit2_init()

  ; lsremote
  val entries = match(libgit2_lsremote_url(remote-url)):
    (entries:Tuple<KeyValue<String,String>>) : entries
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
        throw(LibGitException(e, "failed to list remote references of %_: %_" % [remote-url, last-err-msg]))

  ; Build table, filter non-tag references
  val result = to-hashtable<String,String> $ for entry in entries filter :
    val tag = value(entry)
    (length(tag) > 10) and (tag[0 to 10] == "refs/tags/")

  ; Cleanup
  libgit2_shutdown()

  result
