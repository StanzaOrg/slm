defpackage slm/libgit-utils:
  import core
  import collections

  import libgit2

  import slm/utils
  import slm/dependency
  import slm/logging
  import slm/git-dep

;============================================================
;====================== Libgit2 Utils =======================
;============================================================

public defstruct LibGitException <: Exception :
  code: git_error_code
  msg: ?

public defmethod print (o:OutputStream, e:LibGitException):
  print(o, "Libgit error: %_" % [msg(e)])

; Finds and returns the object ID of the reference 'refish' in the repository at
; 'path'
; Throws an exception if unsuccessful
public defn libgit-rev-parse (path:String, refish:String) -> String :
  libgit2_init()

  ; Open
  val repo = match(libgit2_repository_open(path)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to open git repository in %_: %_" % [path, last-err-msg]))

  ; Rev-parse
  val result = match(libgit2_revparse(repo, refish)):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to parse reference %_: %_" % [refish, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()

  result

; Clones the repository for the Git dependency and performs a forced checkout
; of the tag of the dependency's version
; Assumes the remote name is "origin"
; Throws an exception if unsuccessful
public defn libgit-fetch-dependency (dep:GitDependency) -> False :
  val name = /name(dep)
  val url = full-url-from-locator(locator(dep))
  val path = /path(dep)
  val tag = to-string("v%~" % [version(dep)])
  val full-tag = to-string("refs/tags/%_" % [tag])
  val refspec = to-string("+%_:%_" % [full-tag, full-tag])

  ; Initialize libgit
  libgit2_init()

  ; Clone
  val repo = match(libgit2_clone(url, path, 1)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to clone dependency %_ at %_: %_" % [name, url, last-err-msg]))

  ; Fetch
  match(libgit2_fetch(repo, "origin", refspec, 1)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to fetch tag %_ for dependency %_: %_" % [tag, name, last-err-msg]))

  ; Checkout
  match(libgit2_checkout(repo, full-tag, GIT_CHECKOUT_FORCE)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to checkout tag %_ for dependency %_: %_" % [tag, name, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()
  false

; Syncs the repository for the Git dependency to the requested version
; Assumes the remote name is "origin"
; Throws an exception if unsuccessful
public defn libgit-sync-dependency (dep:GitDependency) -> False :
  val name = /name(dep)
  val path = /path(dep)
  val tag = to-string("v%~" % [version(dep)])
  val full-tag = to-string("refs/tags/%_" % [tag])
  val refspec = to-string("+%_:%_" % [full-tag, full-tag])

  ; Initialize libgit
  libgit2_init()

  ; Open
  val repo = match(libgit2_repository_open(path)):
    (repo:GIT_REPOSITORY) :
      repo
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to open git repository for dependency %_ at %_: %_" % [name, path, last-err-msg]))

  ; Rev-parse HEAD
  val head-hash = match(libgit2_revparse(repo, "HEAD")):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to find hash of HEAD for dependency %_ at %_: %_" % [name, path, last-err-msg]))
  debug("head-hash: %_" % [head-hash])

  ; Fetch
  match(libgit2_fetch(repo, "origin", refspec, 1)):
    (e:GIT_OK) :
      false
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to fetch tag %_ for dependency %_: %_" % [tag, name, last-err-msg]))

  ; Rev-parse tag
  val tag-hash = match(libgit2_revparse(repo, full-tag)):
    (hash:String) : hash
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_repository_free(repo)
      libgit2_shutdown()
      throw(LibGitException(e, "Failed to parse tag %_ for dependency %_: %_" % [tag, name, last-err-msg]))
  debug("tag-hash: %_" % [tag-hash])

  ; Checkout
  if head-hash != tag-hash :
    info("syncing %_ to %~" % [colored-name?(dep), colored-version?(dep)])
    match(libgit2_checkout(repo, full-tag, GIT_CHECKOUT_FORCE)):
      (e:GIT_OK) :
        false
      (e:git_error_code) :
        val last-err-msg = message(libgit2_error_last())
        libgit2_repository_free(repo)
        libgit2_shutdown()
        throw(LibGitException(e, "Failed to checkout tag %_ for dependency %_: %_" % [tag, name, last-err-msg]))

  ; Cleanup
  libgit2_repository_free(repo)
  libgit2_shutdown()
  false

; Returns a table of hash => reference name for all tags of the remote at the
; URL 'remote-url'
; Throws an exception if unsuccessful
public defn libgit-lsremote-tags (remote-url:String) -> HashTable<String,String> :
  libgit2_init()

  ; lsremote
  val entries = match(libgit2_lsremote_url(remote-url)):
    (entries:Tuple<KeyValue<String,String>>) : entries
    (e:git_error_code) :
      val last-err-msg = message(libgit2_error_last())
      libgit2_shutdown()
        throw(LibGitException(e, "Failed to list remote references of %_: %_" % [remote-url, last-err-msg]))

  ; Build table, filter non-tag references
  val result = to-hashtable<String,String> $ for entry in entries filter :
    val tag = value(entry)
    (length(tag) > 10) and (tag[0 to 10] == "refs/tags/")

  ; Cleanup
  libgit2_shutdown()

  result
