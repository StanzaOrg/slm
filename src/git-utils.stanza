defpackage slm/git-utils:
  import core
  import collections

  import maybe-utils
  import semver

  import slm/file-utils
  import slm/process-utils

defn parse-git-version (msg:String) -> Maybe<SemanticVersion> :
  val comps = split(msg, " ")
  for comp in comps first:
    parse-semver(comp)

defn run-git-version () -> Maybe<SemanticVersion> :
  try:
    val p = ProcessBuilder(["git", "version"])
      $> with-output
      $> build

    ; Evidently - you have to call `get-output` before `run` here
    ;   Otherwise, it will throw an "Bad file descriptor" error.
    val msg = get-output(p) $> trim
    val code = run-and-get-exit-code(p)
    if code == 0:
      parse-git-version(msg)
    else if code == 127:
      ; This indicates that there is no `git` on the path:
      None()
    else:
      println("Error checking 'git version': code = %_ \n %_" % [code, msg])
      None()
  catch (e:ProcessLaunchError):
    ; Launch failure is synonymous with executable not found.
    None()

var git-vers:Maybe<SemanticVersion> = run-git-version()

public defn git-version? () -> Maybe<SemanticVersion> :
  git-vers

public defn has-git? () -> True|False :
  match(git-version?()):
    (x:One<SemanticVersion>): true
    (_:None): false

public defn git-rev-parse (work-tree: String, rev: String) -> String:
  command-output-in-dir(work-tree, ["git", "rev-parse", "--verify", "--quiet", rev])

public defn git-rev-parse! (work-tree: String, rev: String) -> String:
  val ret = git-rev-parse(work-tree, rev)
  if empty?(ret):
    throw(Exception("git rev-parse failed!"))
  ret

public defn git-remote-tag-refs (remote: String) -> HashTable<String, String>:
  val output = call-system-and-get-output("git", ["git", "ls-remote", "-q", "--tags", remote])
  val pairs = to-tuple $ split(output, "\n")
  to-hashtable<String, String> $ seq?{_, pairs} $ fn (line):
    val elements = to-tuple $ split(line, "\t")
    if length(elements) == 2:
      One(elements[1] => elements[0])
    else:
      None()

public defn run-git-command-in-dir (work-tree?: Maybe<String>, args0: Tuple<String>) -> Int:
  val args = to-tuple $ cat(["git"], args0)
  val work-tree = work-tree? $> value-or{_, get-cwd()}
  val process = ProcessBuilder(args)
    $> in-dir{_, work-tree}
    $> build
  wait-process-throw-on-nonzero(process, "'%_' failed!" % [string-join(args, " ")])

public defn run-git-command-in-dir (work-tree: String, args0: Tuple<String>) -> Int:
  run-git-command-in-dir(One(work-tree), args0)

public defn run-git-command (args0: Tuple<String>) -> Int:
  run-git-command-in-dir(None(), args0)

public defn shallow-clone-git-repo (
  url: String,
  directory: String
) -> Int:
  run-command-throw-on-error(["git", "clone", url, "--quiet", "--depth", "1", directory],
                             "'git clone %_' failed!" % [url])

public defn git-init (path: String) -> Int:
  run-command-throw-on-error(["git", "init", "--quiet", path],
                             "'git init %_' failed!" % [path])

