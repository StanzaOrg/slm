defpackage slm/commands/init:
  import core
  import arg-parser
  import core/parsed-path
  import collections

  import maybe-utils
  import toml

  import slm/flags
  import slm/file-utils
  import slm/git-utils
  import slm/logging
  import slm/utils
  import slm/commands/version with:
    only => (BIN-VERSION)

; I have two levels of string formatting here so that I can
;  insert some general global values before the `init`
;  command runs.
; NOTE: The `include?` syntax means - "Optionally include `.slm/stanza.proj`
;  if it exists". This is useful for the case where we try to use a project
;  that compiles to a binary as a dependency. In this case, `slm` won't
;  setup the `.slm` directory in the child or grand-children dependencies - it will
;  flatten it all to the top level.
val PROJ-PROTO-TEMPLATE = \<TMP>; Generated by slm version %_
include? "%_/stanza.proj"  ; Dependencies

pkg-cache: "%_/pkg-cache"
%%_<TMP> ; Optional 'non-minimal' section

val PROJ-TEMPLATE = to-string(PROJ-PROTO-TEMPLATE % [BIN-VERSION, SLM_DIR, SLM_DIR])

; Extra section to be inserted into PROJ-TEMPLATE if the '-minimal' flag is
; not set
val NON-MINIMAL-TEMPLATE = \<TMP>
packages %_/* defined-in "src/"

build main:
  inputs: %_
  pkg: "%_"
  o: "%_"
<TMP>

val MAIN-TEMPLATE = \<TMP>
defpackage %_:
  import core

defn main () -> False:
  println("Hello, world!")

main()
<TMP>

; Gets the fully-resolved path of the directory where we're initializing
; a package. If no path was given, uses the current directory.
defn get-proj-dir (cmd-args:CommandArgs) -> String :
  val args = /args(cmd-args)
  val raw-path = args[0] when length(args) > 0 else get-cwd()
  to-string(normalize(parse-path(raw-path)))

; Run the init command
public defn init (cmd-args:CommandArgs) -> False:
  val minimal? = flag?(cmd-args, "minimal")
  val project-dir = get-proj-dir(cmd-args)

  val project-name = base-name?(project-dir)
    $> value-or{_, project-dir}

  val slm-toml-path = path-join(project-dir, SLM_TOML_NAME)
  val slm-dir-path = path-join(project-dir, SLM_DIR)

  if file-exists?(project-dir):
    ; Check that a package wasn't already initialized
    for path in [slm-toml-path, slm-dir-path] do:
      if file-exists?(path):
        error("package already initialized (`%_` exists)" % [path])
  else:
    create-dir(project-dir)

  ; Create our initial package structure:
  ;   - .slm/
  ;     - pkgs/
  ;     - pkg-cache/
  ;     - deps/
  ;     - stanza.proj
  ;   - .gitignore
  ;   - slm.toml
  ;   - stanza.proj
  ;   - src (non-minimal)
  ;     - main.stanza (non-minimal)

  ; Create empty .slm directory structure
  create-dir(slm-dir-path)

  val slm-proj = path-join(project-dir, SLM_STANZA_PROJ)
  create-empty-file(slm-proj)

  for build-dir in SLM_BUILD_DIRS do:
    val fp = path-join(project-dir, build-dir)
    create-dir(fp)

  ; Create .gitignore
  val git-ignore = path-join(project-dir, ".gitignore")
  within f = open(git-ignore, file-exists?(git-ignore)):
    println(f, SLM_DIR)

  ; Create slm.toml
  within f = open(slm-toml-path, false):
    println(f, "name = %~" % [project-name])
    println(f, "version = \"0.1.0\"")
    println(f, "[dependencies]")

  ; Create stanza.proj
  val main-package = path-join(project-name, "main")
  val stanza-proj-path = path-join(project-dir, "stanza.proj")
  val pkg-path = path-join(SLM_DIR, "pkgs")
  if not file-exists?(stanza-proj-path):
    val content =
      if minimal? :
        PROJ-TEMPLATE % [""]
      else :
        PROJ-TEMPLATE % [NON-MINIMAL-TEMPLATE % [project-name, main-package,
          pkg-path, project-name]]
    spit(stanza-proj-path, content)

  if not minimal? :
    ; Create src/
    val project-src-dir = path-join(project-dir, "src")
    if not file-exists?(project-src-dir):
      create-dir(project-src-dir)

    ; Create src/main.stanza
    val project-main-path = path-join(project-src-dir, "main.stanza")
    if not file-exists?(project-main-path):
      val content = MAIN-TEMPLATE % [main-package]
      spit(project-main-path, content)

  ; Initialize Git repo if we aren't already inside
  ;  a git repo.
  if has-git?() and not git-status(project-dir):
    git-init(project-dir)

  println("slm: init: package `%_` initialized in `%_`"
          % [project-name, project-dir])

  false

val INIT-MSG = \<MSG>
The 'init' command will initialize a 'slm' package structure into
the passed directory.

If there are existing files present in the new project directory,
those files _will not_ be overwritten.

Content Created:
- .slm directory & associated directories
- slm.toml
- Default Stanza Project:
  - stanza.proj
  - src directory and initial main.stanza

Example:

Initialize a brand new project:

$> cd new_project
$> slm init

Initialize an existing project:

$> git clone ssh://git@github.com/user/existing
$> slm init ./existing

<MSG>

val INIT-ARG-MSG = \<MSG>
Optional directory to setup a 'slm' package.

If an argument is not provided, then the current working directory is where the new package
files will be created.
<MSG>

val MINIMAL-MSG = \<MSG>
Do not create a 'main.stanza' file and its associated build rule
<MSG>

public defn setup-init-cmd () -> Command :
  val flags = [
    Flag("minimal", ZeroFlag, OptionalFlag, MINIMAL-MSG)
    ]
  Command(name = "init",
    action = init
    argtype = ZeroOrOneArg,
    arg-description = INIT-ARG-MSG,
    description = INIT-MSG,
    flags = flags)
