defpackage slm/commands/init:
  import core
  import arg-parser
  import core/parsed-path
  import collections

  import maybe-utils
  import toml/file
  import toml/table
  import toml/value

  import slm/file-utils
  import slm/git-utils
  import slm/logging

defn get-proj-dir (cmd-args:CommandArgs) -> Maybe<String> :
  val arg = args(cmd-args)
  if (length(arg) == 1 ): One(arg[0])
  else: None()

public defn init (cmd-args:CommandArgs) -> False:
  val project-dir* = get-proj-dir(cmd-args)

  ; First get the fully-resolved path of the directory where we're initializing
  ; a package. If no path was given, use the current directory.
  val project-dir = project-dir*
    $> map{_, parse-path}
    $> map{_, normalize}
    $> map{_, to-string}
    $> value-or{_, get-cwd()}

  val project-name = dir-name?(project-dir)
    $> value-or{_, project-dir}

  val slm-toml-path = to-string("%_/slm.toml" % [project-dir])
  val slm-dir-path = to-string("%_/.slm/" % [project-dir])

  if file-exists?(project-dir):
    ; Check that a package wasn't already initialized
    for path in [slm-toml-path, slm-dir-path] do:
      if file-exists?(path):
        error("package already initialized (`%_` exists)" % [path])
  else:
    create-dir(project-dir)

  ; Create our initial package structure:
  ;   - .slm/
  ;     - pkgs/
  ;     - deps/
  ;     - stanza.proj
  ;   - .gitignore
  ;   - slm.toml
  ;   - stanza.proj
  ;   - src
  ;     - stanza.proj
  ;     - main.stanza

  ; Create empty .slm directory structure
  create-dir(slm-dir-path)
  val pkg-path = to-string("%_/pkgs/" % [slm-dir-path])
  create-dir(pkg-path)
  create-dir(to-string("%_/deps/" % [slm-dir-path]))
  create-empty-file(to-string("%_/stanza.proj" % [slm-dir-path]))

  ; Create .gitignore
  val git-ignore = to-string("%_/.gitignore" % [project-dir])
  within f = open(git-ignore, file-exists?(git-ignore)):
    println(f, ".slm")

  ; Create slm.toml
  within f = open(slm-toml-path, false):
    println(f, "name = %~" % [project-name])
    println(f, "version = \"0.1.0\"")
    println(f, "[dependencies]")

  ; Create stanza.proj
  val main-package = to-string("%_/main" % [project-name])
  val stanza-proj-path = to-string("%_/stanza.proj" % [project-dir])
  if not file-exists?(stanza-proj-path):
    spit(stanza-proj-path, \<>include ".slm/stanza.proj"  ; Dependencies
include "src/stanza.proj"  ; Project Sources

build main:
  inputs: %_
  pkg: "%_"
  o: "%_"
<>
        % [main-package, pkg-path, project-name])

  ; Create src/
  val project-src-dir = to-string("%_/src/" % [project-dir])
  if not file-exists?(project-src-dir):
    create-dir(project-src-dir)

  ; Create src/stanza.proj
  val src-stanza-proj-path = to-string("%_/stanza.proj" % [project-src-dir])
  if not file-exists?(src-stanza-proj-path):
    spit{src-stanza-proj-path, _} $
      \<>package %_ defined-in "main.stanza"
<>
      % [main-package]

  ; Create src/main.stanza
  val project-main-path = to-string("%_/main.stanza" % [project-src-dir])
  if not file-exists?(project-main-path):
    spit{project-main-path, _} $
      \<>defpackage %_:
  import core

defn main () -> False:
  println("Hello, world!")

main()
<>
      % [main-package]

  ; Initialize Git repo in .git
  val git-dir = to-string("%_/.git/" % [project-dir])
  if not file-exists?(git-dir):
    git-init(project-dir)

  println("slm: init: package `%_` initialized in `%_`"
          % [project-name, project-dir])

  false

val INIT-MSG = \<MSG>
The 'init' command will initial a 'slm' package structure into
the passed directory.

If there are existing files present in the new project directory,
those files _will not_ be overwritten.

Content Created:
- .slm directory & associated directories
- slm.toml
- Default Stanza Project:
  - stanza.proj
  - src directory and initial main.stanza

Example:

Initialize a brand new project:

$> cd new_project
$> slm init

Initialize an existing project:

$> git clone ssh://git@github.com/user/existing
$> slm init ./existing

<MSG>

val INIT-ARG-MSG = \<MSG>
Optional directory to setup a 'slm' package.

If an argument is not provided, then the current working directory is where the new package
files will be created.
<MSG>

public defn setup-init-cmd () -> Command :
  Command("init", ZeroOrOneArg, INIT-ARG-MSG, [], INIT-MSG, init)