defpackage slm/commands/build:
  import core
  import arg-parser
  import core/parsed-path

  import maybe-utils
  import semver
  import term-colors
  import toml/file
  import toml/parser
  import toml/table
  import toml/value

  import slm/dependency
  import slm/dependencies
  import slm/file-utils
  import slm/lock
  import slm/logging
  import slm/process-utils
  import slm/flags
  import slm/toml

public defn ensure-slm-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(".slm/"):
    create-dir!(".slm/deps/")
    create-dir!(".slm/pkgs/")
  false

defn write-build-stanza-proj (dependencies: Tuple<Dependency>) -> False:
  within f = open(".slm/stanza.proj", false):
    val deps-dir = to-string("%_/.slm/deps/" % [get-cwd()])
    for dep in dependencies do:
      val dep-path = get-cwd() $> parse-path $> relative-to-dir{_, dep $> /path}
      println(f, to-string(\<>include "%_/stanza.proj"<> % [dep-path]))
    println(f, \<>include "../stanza.proj"<>)

defn write-slm-lock-file (dependencies: Tuple<Dependency>) -> False:
  within f = open("slm.lock", false):
    for dep in dependencies do:
      match(dep):
        (dep: GitDependency):
          println(f, "%_={locator=%~,version=%~,hash=%~}"
                  % [name(dep), locator(dep), to-string(version(dep)), hash(dep)])
        (dep: PathDependency):
          println(f, "%_={}" % [name(dep)])

defn get-build-args () -> Tuple<String>:
  val ret = get-env("SLM_BUILD_ARGS")
  match(ret):
    (x:String): to-tuple $ split(x, " ")
    (x:False): []

defn get-build-target (cmd-args:CommandArgs) -> Tuple<String> :
  val arg = args(cmd-args)
  switch(length(arg)):
    1:
      debug("Target: '%_'" % [arg[0]])
      [arg[0]]
    0: []
    else:
      error("Invalid Number of Targets: %_" % [length(arg)])

public defn build (cmd-args:CommandArgs) -> False:
  val verbose =  get?(cmd-args, "verbose", false)
  if verbose:
    slm/flags/debug? = true

  val targ? = get-build-target(cmd-args)

  ensure-slm-dir-structure-exists()

  val dependencies = slm/dependencies/fetch-and-sync()

  write-build-stanza-proj(dependencies)
  write-slm-lock-file(dependencies)

  val slm-dir = to-string("%_/.slm" % [get-cwd()])

  val build-args = get-build-args()
  debug("with build args '%,'" % [build-args])

  val args = to-tuple $ cat-all([["stanza", "build"], targ?, build-args, ["-pkg", "pkgs"]])
  val vStr = parse-slm-toml("slm.toml") $> /version
  debug("Build Version: %_" % [vStr])
  val env-vars = ["SLM_BUILD_VERSION" => vStr]
  debug("Stanza: %," % [args])
  ProcessBuilder(args)
    $> in-dir{_, slm-dir}
    $> with-env-vars{_, env-vars}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}

  false

val BUILD-MSG = \<MSG>
The 'build' command will manage syncing dependencies and then
building the project using the 'stanza build' process.

The user can pass arguments to the 'stanza build' process
by using the 'SLM_BUILD_ARGS' environment variable.

Example:

$> SLM_BUILD_ARGS="-flag TESTING" slm build

---------------------------
Package Version Propagation
---------------------------

In order for the package's source code to know what its current
version number is, this tool defines 'SLM_BUILD_VERSION' with the
'version' string value from the 'slm.toml' file. This environment
variable is defined for the context of the `stanza build` process.

This allows the package's stanza code to use '#env-var(SLM_BUILD_VERSION)'
to access this version string and compile it into the binary or library
that is being constructed.

<MSG>

val BUILD-MSG-ARG = \<MSG>

The build command takes an optional argument which is the target in the
stanza.proj file to build. Without this optional argument, the command
follows the `stanza build` command's logic and compiles the `main` target.

Running:

```
$> slm build target
```

Is effectively the same as running:

```
$> stanza build target
```

But with all the dependencies handled.

<MSG>

val VERBOSE-FLAG = \<MSG>
Generate verbose output from build.
<MSG>

public defn setup-build-cmd () -> Command :
  val buildFlags = [
    Flag("verbose", ZeroFlag, OptionalFlag, VERBOSE-FLAG)
  ]
  Command("build", ZeroOrOneArg, BUILD-MSG-ARG, buildFlags, BUILD-MSG, build)