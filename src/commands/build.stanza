defpackage slm/commands/build:
  import core
  import arg-parser
  import core/parsed-path

  import maybe-utils
  import semver
  import term-colors
  import toml/file
  import toml/parser
  import toml/table
  import toml/value

  import slm/dependency
  import slm/dependencies
  import slm/file-utils
  import slm/lock
  import slm/logging
  import slm/process-utils
  import slm/flags
  import slm/toml
  import slm/utils

public defn ensure-slm-dir-structure-exists () -> False:
  defn create-dir! (path: String) -> True|False:
    if not file-exists?(path):
      create-dir(path)
      true

  if create-dir!(SLM_DIR):
    for build-dir in [SLM_DEPS_DIR, SLM_PKGS_DIR] do:
      create-dir!(build-dir)
  false

defn write-build-stanza-proj (dependencies: Tuple<Dependency>) -> False:
  within f = open(SLM_STANZA_PROJ, false):
    val deps-dir = path-join(get-cwd(), SLM_DEPS_DIR)
    for dep in dependencies do:
      val dep-path = get-cwd() $> parse-path $> relative-to-dir{_, dep $> /path}
      val dep-stanza-proj = path-join(to-string(dep-path), "stanza.proj")
      println(f, to-string(\<>include "%_"<> % [dep-stanza-proj]))

defn write-slm-lock-file (dependencies: Tuple<Dependency>) -> False:
  within f = open(SLM_LOCK_NAME, false):
    for dep in dependencies do:
      match(dep):
        (dep: GitDependency):
          println(f, "%_={locator=%~,version=%~,hash=%~}"
                  % [name(dep), locator(dep), to-string(version(dep)), hash(dep)])
        (dep: PathDependency):
          println(f, "%_={}" % [name(dep)])

defn get-build-args () -> Tuple<String>:
  val ret = get-env("SLM_BUILD_ARGS")
  match(ret):
    (x:String): to-tuple $ split(x, " ")
    (x:False): []

defn get-build-target (cmd-args:CommandArgs) -> Tuple<String> :
  val arg = args(cmd-args)
  switch(length(arg)):
    1:
      debug("Target: '%_'" % [arg[0]])
      [arg[0]]
    0: []
    else:
      error("Invalid Number of Targets: %_" % [length(arg)])

public defn build (cmd-args:CommandArgs) -> False:
  val verbose =  get?(cmd-args, "verbose", false)
  if verbose:
    slm/flags/debug? = true

  val targ? = get-build-target(cmd-args)

  ensure-slm-dir-structure-exists()

  val dependencies = slm/dependencies/fetch-and-sync()

  write-build-stanza-proj(dependencies)
  write-slm-lock-file(dependencies)

  val slm-dir = path-join(get-cwd(), SLM_DIR)

  val cfg = parse-slm-toml(SLM_TOML_NAME)
  val stanza-exe = get-stanza-exe(compiler?(cfg))
  debug("with stanza='%_'" % [stanza-exe])

  val build-args = get-build-args()
  debug("with build args '%,'" % [build-args])

  ; In general - we want all of the options for the project to be
  ;  captured in the `stanza.proj` file - not as options passed to this command.
  ;  Otherwise, the user will have to remember to pass `-pkg pkgs` on the command
  ;  line to the `stanza build` if they want to run the compiler directly instead
  ;  of through `slm`
  val args = to-tuple $ cat-all([[stanza-exe, "build"], targ?, build-args])
  val vStr =  version(cfg)
  debug("Build Version: %_" % [vStr])
  val env-vars = ["SLM_BUILD_VERSION" => vStr]
  debug("Stanza: %," % [args])
  ProcessBuilder(args)
    $> with-env-vars{_, env-vars}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}

  false

val BUILD-MSG = \<MSG>
The 'build' command will manage syncing dependencies and then
building the project using the 'stanza build' process.

The user can pass arguments to the 'stanza build' process
by using the 'SLM_BUILD_ARGS' environment variable.

Example:

$> SLM_BUILD_ARGS="-flag TESTING" slm build

---------------------------
Package Version Propagation
---------------------------

In order for the package's source code to know what its current
version number is, this tool defines 'SLM_BUILD_VERSION' with the
'version' string value from the 'slm.toml' file. This environment
variable is defined for the context of the `stanza build` process.

This allows the package's stanza code to use '#env-var(SLM_BUILD_VERSION)'
to access this version string and compile it into the binary or library
that is being constructed.

<MSG>

val BUILD-MSG-ARG = \<MSG>

The build command takes an optional argument which is the target in the
stanza.proj file to build. Without this optional argument, the command
follows the `stanza build` command's logic and compiles the `main` target.

Running:

```
$> slm build target
```

Is effectively the same as running:

```
$> stanza build target
```

But with all the dependencies handled.

<MSG>

val VERBOSE-FLAG = \<MSG>
Generate verbose output from build.
<MSG>

public defn setup-build-cmd () -> Command :
  val buildFlags = [
    Flag("verbose", ZeroFlag, OptionalFlag, VERBOSE-FLAG)
  ]
  Command("build", ZeroOrOneArg, BUILD-MSG-ARG, buildFlags, BUILD-MSG, build)