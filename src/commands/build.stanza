defpackage slm/commands/build:
  import core
  import collections
  import arg-parser
  import core/parsed-path

  import maybe-utils
  import semver
  import term-colors
  import toml/file
  import toml/parser
  import toml/table
  import toml/value

  import slm/dependency
  import slm/dependencies
  import slm/file-utils
  import slm/lock
  import slm/logging
  import slm/process-utils
  import slm/flags
  import slm/toml
  import slm/utils
  import slm/stanza-utils

defn get-build-target (cmd-args:CommandArgs) -> Tuple<String> :
  val arg = args(cmd-args)
  switch(length(arg)):
    1:
      debug("Target: '%_'" % [arg[0]])
      [arg[0]]
    0: []
    else:
      error("Invalid Number of Targets: %_" % [length(arg)])

public defn build (cmd-args:CommandArgs) -> False:
  val verbose =  get?(cmd-args, "verbose", false)
  if verbose:
    slm/flags/debug? = true

  val force-build = get?(cmd-args, "force", false)
  val build-args = get?(cmd-args, "-", [])
  val targ? = get-build-target(cmd-args)

  val cfg = parse-slm-toml(SLM_TOML_NAME)
  get-proj-stanza-version!(compiler?(cfg))

  val dependencies = slm/dependencies/fetch-and-sync()

  val non-compat = check-stanza-versions(cfg, dependencies)
  if length(non-compat) > 0:
    if force-build:
      info("Stanza Compatibility Check Failed - Proceeding by Force")
    else:
      val name-version = for [name, msg] in pairs(non-compat) seq:
        "'%_' %_" % [name, msg]
      val content = string-join(name-version, "\n")
      info("Current Stanza Version: %_" % [get-stanza-version!()])
      info("Dependencies with Stanza Version Issues:")
      info(content)
      error("Stanza Version Compatibility Check Failed")

  val slm-dir = path-join(get-cwd(), SLM_DIR)

  val stanza-exe = get-stanza-exe(compiler?(cfg))
  debug("with stanza='%_'" % [stanza-exe])
  debug("with build args '%,'" % [build-args])

  ; In general - we want all of the options for the project to be
  ;  captured in the `stanza.proj` file - not as options passed to this command.
  ;  Otherwise, the user will have to remember to pass `-pkg pkgs` on the command
  ;  line to the `stanza build` if they want to run the compiler directly instead
  ;  of through `slm`
  val args = to-tuple $ cat-all([[stanza-exe, "build"], targ?, build-args])
  val vStr =  version(cfg)
  debug("Build Version: %_" % [vStr])
  val env-vars = ["SLM_BUILD_VERSION" => vStr]
  debug("Stanza: %," % [args])
  ProcessBuilder(args)
    $> with-env-vars{_, env-vars}
    $> build
    $> wait-process-throw-on-nonzero{_, "build failed!"}

  false

val BUILD-MSG = \<MSG>
The 'build' command will manage syncing dependencies and then
building the project using the 'stanza build' process.

The user can pass arguments to the 'stanza build' process
by using the '-' flag argument.

Example:

$> slm build -- -flags TESTING

---------------------------
Package Version Propagation
---------------------------

In order for the package's source code to know what its current
version number is, this tool defines 'SLM_BUILD_VERSION' with the
'version' string value from the 'slm.toml' file. This environment
variable is defined for the context of the `stanza build` process.

This allows the package's stanza code to use '#env-var(SLM_BUILD_VERSION)'
to access this version string and compile it into the binary or library
that is being constructed.

<MSG>

val BUILD-MSG-ARG = \<MSG>

The build command takes an optional argument which is the target in the
stanza.proj file to build. Without this optional argument, the command
follows the `stanza build` command's logic and compiles the `main` target.

Running:

```
$> slm build target
```

Is effectively the same as running:

```
$> stanza build target
```

But with all the dependencies handled.

<MSG>

val VERBOSE-FLAG = \<MSG>
Generate verbose output from build.
<MSG>

val FORCE-FLAG = \<MSG>
This flag instructs the build system to ignore any stanza
version compatibility checks and attempt to build this project
regardless.
<MSG>

val BUILD-ARGS-FLAG = \<MSG>
To pass additional build arguments directly to the
stanza build invokation, the user can use the '--'
sequence. All arguments after the '--' will be
passed directly to the build.
<MSG>

public defn setup-build-cmd () -> Command :
  val buildFlags = [
    Flag("verbose", ZeroFlag, OptionalFlag, VERBOSE-FLAG)
    Flag("force", ZeroFlag, OptionalFlag, FORCE-FLAG),
    Flag("-", AllRemainingFlag, OptionalFlag, BUILD-ARGS-FLAG)

  ]
  Command("build", ZeroOrOneArg, BUILD-MSG-ARG, buildFlags, BUILD-MSG, build)